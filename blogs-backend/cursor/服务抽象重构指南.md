# 服务抽象重构指南

## 目录
- [概述](#概述)
- [阶段一：文件存储服务抽象](#阶段一文件存储服务抽象)
- [阶段二：认证服务抽象](#阶段二认证服务抽象)
- [阶段三：工作流服务预留](#阶段三工作流服务预留)
- [阶段四：通知服务扩展](#阶段四通知服务扩展)
- [阶段五：缓存服务抽象](#阶段五缓存服务抽象)
- [执行检查清单](#执行检查清单)

---

## 概述

### 为什么需要抽象？

1. **单一职责原则**：Controller 只处理 HTTP 请求，Service 只处理业务逻辑
2. **开闭原则**：对扩展开放，对修改关闭
3. **依赖倒置原则**：依赖接口，不依赖具体实现
4. **可测试性**：接口可以轻松 mock，便于单元测试
5. **可扩展性**：未来切换实现（本地→OSS、Session→JWT）无需大改

### 抽象优先级

| 服务 | 优先级 | 理由 |
|------|--------|------|
| 文件存储服务 | 最高 | 部署环境变化时必须切换（本地→OSS） |
| 认证服务 | 高 | 未来可能需要 JWT、OAuth2 等 |
| 工作流服务 | 中 | 为未来复杂审批流程预留 |
| 通知服务 | 中 | 支持多渠道通知（邮件、短信等） |
| 缓存服务 | 中-低 | 性能优化时需要 |

---

## 阶段一：文件存储服务抽象

### 当前问题
- `FileController` 直接操作本地文件系统
- 硬编码存储逻辑，难以切换到 OSS/MinIO
- Controller 职责混乱，包含文件系统操作

### 目标
- 抽象文件存储接口
- 支持本地存储、OSS、MinIO 等多种实现
- 通过配置文件切换存储方式

### 步骤1.1：创建文件存储服务接口

**文件路径**：`src/main/java/com/gdblogs/service/FileStorageService.java`

```java
package com.gdblogs.service;

import org.springframework.web.multipart.MultipartFile;

/**
 * 文件存储服务接口
 * 支持本地存储、OSS、MinIO 等多种实现
 */
public interface FileStorageService {
    
    /**
     * 上传文件
     * @param file 文件
     * @param category 文件分类（如：image/document/video）
     * @return 文件访问URL
     */
    String uploadFile(MultipartFile file, String category);
    
    /**
     * 删除文件
     * @param fileUrl 文件URL
     * @return 是否成功
     */
    boolean deleteFile(String fileUrl);
    
    /**
     * 获取文件访问URL（用于CDN等场景）
     * @param filePath 文件路径
     * @return 完整访问URL
     */
    String getFileUrl(String filePath);
}
```

### 步骤1.2：创建本地存储实现类

**文件路径**：`src/main/java/com/gdblogs/service/impl/LocalFileStorageServiceImpl.java`

```java
package com.gdblogs.service.impl;

import cn.hutool.core.util.StrUtil;
import com.gdblogs.exception.BusinessException;
import com.gdblogs.exception.ErrorCode;
import com.gdblogs.service.FileStorageService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.util.UUID;

/**
 * 本地文件存储服务实现
 */
@Service
@Slf4j
@ConditionalOnProperty(name = "storage.type", havingValue = "local", matchIfMissing = true)
public class LocalFileStorageServiceImpl implements FileStorageService {

    @Value("${file.upload-dir}")
    private String uploadDir;

    @Value("${file.base-url:}")
    private String baseUrl;

    @Override
    public String uploadFile(MultipartFile file, String category) {
        // 参数校验
        if (file.isEmpty()) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "文件为空");
        }

        // 校验文件类型（根据category）
        if ("image".equals(category)) {
            String contentType = file.getContentType();
            if (contentType == null || !contentType.startsWith("image/")) {
                throw new BusinessException(ErrorCode.PARAMS_ERROR, "只能上传图片");
            }
            // 校验文件大小（5MB）
            if (file.getSize() > 5 * 1024 * 1024) {
                throw new BusinessException(ErrorCode.PARAMS_ERROR, "图片大小不能超过5MB");
            }
        }

        try {
            // 生成唯一文件名
            String originalFilename = file.getOriginalFilename();
            if (originalFilename == null) {
                throw new BusinessException(ErrorCode.PARAMS_ERROR, "文件名为空");
            }
            
            String extension = "";
            int dotIndex = originalFilename.lastIndexOf(".");
            if (dotIndex > 0) {
                extension = originalFilename.substring(dotIndex);
            }
            
            String filename = System.currentTimeMillis() + "_" + UUID.randomUUID() + extension;

            // 确保目录存在
            File folder = new File(uploadDir);
            if (!folder.exists()) {
                boolean created = folder.mkdirs();
                if (!created) {
                    throw new BusinessException(ErrorCode.SYSTEM_ERROR, "创建上传目录失败");
                }
            }

            // 保存文件
            File dest = new File(folder, filename);
            file.transferTo(dest.getAbsoluteFile());

            log.info("文件保存成功: {}", dest.getAbsolutePath());
            
            // 返回访问 URL
            String url = "/uploads/images/" + filename;
            if (StrUtil.isNotBlank(baseUrl)) {
                url = baseUrl + url;
            }
            
            log.info("文件上传成功: {}", url);
            return url;

        } catch (IOException e) {
            log.error("文件上传失败", e);
            throw new BusinessException(ErrorCode.SYSTEM_ERROR, "上传失败");
        }
    }

    @Override
    public boolean deleteFile(String fileUrl) {
        try {
            // 从URL中提取文件名
            String filename = fileUrl.substring(fileUrl.lastIndexOf("/") + 1);
            File file = new File(uploadDir, filename);
            if (file.exists()) {
                return file.delete();
            }
            return false;
        } catch (Exception e) {
            log.error("删除文件失败: {}", fileUrl, e);
            return false;
        }
    }

    @Override
    public String getFileUrl(String filePath) {
        if (StrUtil.isNotBlank(baseUrl)) {
            return baseUrl + filePath;
        }
        return filePath;
    }
}
```

### 步骤1.3：重构 FileController

**修改文件**：`src/main/java/com/gdblogs/controller/FileController.java`

```java
package com.gdblogs.controller;

import com.gdblogs.annotation.AuthCheck;
import com.gdblogs.common.BaseResponse;
import com.gdblogs.common.ResultUtils;
import com.gdblogs.constant.UserConstant;
import com.gdblogs.service.FileStorageService;
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

/**
 * 文件上传接口
 */
@RestController
@RequestMapping("/file")
@Slf4j
public class FileController {

    @Resource
    private FileStorageService fileStorageService;

    /**
     * 上传图片
     *
     * @param file 图片文件
     * @return 图片访问 URL
     */
    @AuthCheck(mustRole = UserConstant.DEFAULT_ROLE)
    @PostMapping("/upload/image")
    public BaseResponse<String> uploadImage(@RequestParam("file") MultipartFile file) {
        String url = fileStorageService.uploadFile(file, "image");
        return ResultUtils.success(url);
    }
}
```

### 步骤1.4：更新配置文件

**修改文件**：`src/main/resources/application-dev.yml`

```yaml
server:
  port: 8124

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/gd_blogs?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&useSSL=false&allowPublicKeyRetrieval=true
    username: root
    password: 1234
    driver-class-name: com.mysql.cj.jdbc.Driver

# 文件存储配置
file:
  upload-dir: C:/Users/Administrator/Desktop/gd-blogs/blogs-backend/gdblogs/src/main/resources/images/
  base-url: # 可选，用于CDN场景

# 存储类型：local（本地）/ oss（阿里云OSS）/ minio（MinIO）
storage:
  type: local

knife4j:
  enable: true
```

### 步骤1.5：未来扩展 - OSS 实现（可选）

**文件路径**：`src/main/java/com/gdblogs/service/impl/OssFileStorageServiceImpl.java`

```java
package com.gdblogs.service.impl;

import com.gdblogs.service.FileStorageService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

/**
 * 阿里云 OSS 文件存储服务实现（未来扩展）
 */
@Service
@Slf4j
@ConditionalOnProperty(name = "storage.type", havingValue = "oss")
public class OssFileStorageServiceImpl implements FileStorageService {

    // TODO: 注入 OSS 客户端
    
    @Override
    public String uploadFile(MultipartFile file, String category) {
        // TODO: 实现 OSS 上传逻辑
        throw new UnsupportedOperationException("OSS 存储尚未实现");
    }

    @Override
    public boolean deleteFile(String fileUrl) {
        // TODO: 实现 OSS 删除逻辑
        throw new UnsupportedOperationException("OSS 存储尚未实现");
    }

    @Override
    public String getFileUrl(String filePath) {
        // TODO: 返回 OSS URL
        throw new UnsupportedOperationException("OSS 存储尚未实现");
    }
}
```

**配置切换到 OSS**：

```yaml
storage:
  type: oss
  
oss:
  endpoint: https://oss-cn-hangzhou.aliyuncs.com
  access-key-id: your-access-key
  access-key-secret: your-secret-key
  bucket-name: your-bucket
```

---

## 阶段二：认证服务抽象

### 当前问题
- `UserServiceImpl` 混杂了用户数据管理和认证逻辑
- 直接使用 Session，难以切换到 JWT、OAuth2
- 无法支持多种认证方式

### 目标
- 抽象认证服务接口
- 分离用户数据管理和认证逻辑
- 支持 Session、JWT 等多种认证方式

### 步骤2.1：创建认证服务接口

**文件路径**：`src/main/java/com/gdblogs/service/AuthService.java`

```java
package com.gdblogs.service;

import com.gdblogs.model.dto.user.UserLoginRequest;
import com.gdblogs.model.vo.LoginUserVO;
import jakarta.servlet.http.HttpServletRequest;

/**
 * 认证服务接口
 * 支持 Session、JWT、OAuth2 等多种认证方式
 */
public interface AuthService {
    
    /**
     * 用户登录
     * @param userLoginRequest 登录请求
     * @param request HTTP请求
     * @return 脱敏后的用户信息
     */
    LoginUserVO login(UserLoginRequest userLoginRequest, HttpServletRequest request);
    
    /**
     * 用户登出
     * @param request HTTP请求
     * @return 是否成功
     */
    boolean logout(HttpServletRequest request);
    
    /**
     * 获取当前登录用户
     * @param request HTTP请求
     * @return 脱敏后的用户信息
     */
    LoginUserVO getCurrentUser(HttpServletRequest request);
    
    /**
     * 检查是否已登录
     * @param request HTTP请求
     * @return 是否已登录
     */
    boolean isAuthenticated(HttpServletRequest request);
    
    /**
     * 检查是否为管理员
     * @param request HTTP请求
     * @return 是否为管理员
     */
    boolean isAdmin(HttpServletRequest request);
}
```

### 步骤2.2：创建 Session 认证实现

**文件路径**：`src/main/java/com/gdblogs/service/impl/SessionAuthServiceImpl.java`

```java
package com.gdblogs.service.impl;

import cn.hutool.core.util.StrUtil;
import cn.hutool.crypto.digest.DigestUtil;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.gdblogs.constant.UserConstant;
import com.gdblogs.exception.BusinessException;
import com.gdblogs.exception.ErrorCode;
import com.gdblogs.model.dto.user.UserLoginRequest;
import com.gdblogs.model.entity.User;
import com.gdblogs.model.enums.UserRoleEnum;
import com.gdblogs.model.vo.LoginUserVO;
import com.gdblogs.service.AuthService;
import com.gdblogs.service.UserService;
import jakarta.annotation.Resource;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;

import static com.gdblogs.constant.UserConstant.USER_LOGIN_STATE;

/**
 * Session 认证服务实现
 */
@Service
@Slf4j
@ConditionalOnProperty(name = "auth.type", havingValue = "session", matchIfMissing = true)
public class SessionAuthServiceImpl implements AuthService {

    @Resource
    private UserService userService;

    @Override
    public LoginUserVO login(UserLoginRequest userLoginRequest, HttpServletRequest request) {
        // 1. 校验
        String userAccount = userLoginRequest.getUserAccount();
        String userPassword = userLoginRequest.getUserPassword();
        if (StrUtil.hasBlank(userAccount, userPassword)) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "参数为空");
        }
        if (userAccount.length() < 4) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "账号错误");
        }
        if (userPassword.length() < 8) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "密码错误");
        }

        // 2. 加密
        String encryptPassword = DigestUtil.md5Hex(UserConstant.SALT + userPassword);

        // 3. 查询用户
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("userAccount", userAccount);
        queryWrapper.eq("userPassword", encryptPassword);
        User user = userService.getOne(queryWrapper);

        // 用户不存在
        if (user == null) {
            log.info("user login failed, userAccount cannot match userPassword");
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "用户不存在或密码错误");
        }

        // 4. 记录用户的登录态
        request.getSession().setAttribute(USER_LOGIN_STATE, user);

        // 5. 返回脱敏后的用户信息
        return userService.getLoginUserVO(user);
    }

    @Override
    public boolean logout(HttpServletRequest request) {
        if (request.getSession().getAttribute(USER_LOGIN_STATE) == null) {
            throw new BusinessException(ErrorCode.OPERATION_ERROR, "未登录");
        }
        // 移除登录态
        request.getSession().removeAttribute(USER_LOGIN_STATE);
        return true;
    }

    @Override
    public LoginUserVO getCurrentUser(HttpServletRequest request) {
        // 先判断是否已登录
        Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
        User currentUser = (User) userObj;
        if (currentUser == null || currentUser.getId() == null) {
            throw new BusinessException(ErrorCode.NOT_LOGIN_ERROR);
        }
        
        // 从数据库查询（追求性能的话可以注释掉，直接返回 session 中的数据）
        long userId = currentUser.getId();
        currentUser = userService.getById(userId);
        if (currentUser == null) {
            throw new BusinessException(ErrorCode.NOT_LOGIN_ERROR);
        }
        
        return userService.getLoginUserVO(currentUser);
    }

    @Override
    public boolean isAuthenticated(HttpServletRequest request) {
        Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
        return userObj != null;
    }

    @Override
    public boolean isAdmin(HttpServletRequest request) {
        Object userObj = request.getSession().getAttribute(USER_LOGIN_STATE);
        User user = (User) userObj;
        return user != null && UserRoleEnum.ADMIN.getValue().equals(user.getUserRole());
    }
}
```

### 步骤2.3：重构 UserService 接口

**修改文件**：`src/main/java/com/gdblogs/service/UserService.java`

```java
package com.gdblogs.service;

import com.baomidou.mybatisplus.extension.service.IService;
import com.gdblogs.model.dto.user.UserRegisterRequest;
import com.gdblogs.model.dto.user.UserUpdateMyRequest;
import com.gdblogs.model.entity.User;
import com.gdblogs.model.vo.LoginUserVO;
import jakarta.servlet.http.HttpServletRequest;

/**
 * 用户服务（只负责用户数据CRUD，不负责认证）
 */
public interface UserService extends IService<User> {

    /**
     * 用户注册
     *
     * @param userRegisterRequest 注册信息
     * @return 新用户 id
     */
    long userRegister(UserRegisterRequest userRegisterRequest);

    /**
     * 更新个人信息
     *
     * @param userUpdateMyRequest 更新请求
     * @param request             HttpServletRequest
     * @return 是否成功
     */
    boolean updateMyUser(UserUpdateMyRequest userUpdateMyRequest, HttpServletRequest request);

    /**
     * 获取脱敏后的用户信息
     *
     * @param user 用户实体
     * @return 脱敏后的用户信息
     */
    LoginUserVO getLoginUserVO(User user);
}
```

### 步骤2.4：重构 UserServiceImpl

**修改文件**：`src/main/java/com/gdblogs/service/impl/UserServiceImpl.java`

移除以下方法（迁移到 AuthService）：
- `userLogin` → `AuthService.login`
- `userLogout` → `AuthService.logout`
- `getLoginUser` → `AuthService.getCurrentUser`
- `isAdmin` → `AuthService.isAdmin`

修改后的代码：

```java
package com.gdblogs.service.impl;

import cn.hutool.core.util.StrUtil;
import cn.hutool.crypto.digest.DigestUtil;
import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import com.gdblogs.constant.UserConstant;
import com.gdblogs.exception.BusinessException;
import com.gdblogs.exception.ErrorCode;
import com.gdblogs.mapper.UserMapper;
import com.gdblogs.model.dto.user.UserRegisterRequest;
import com.gdblogs.model.dto.user.UserUpdateMyRequest;
import com.gdblogs.model.entity.User;
import com.gdblogs.model.enums.UserRoleEnum;
import com.gdblogs.model.vo.LoginUserVO;
import com.gdblogs.service.AuthService;
import com.gdblogs.service.UserService;
import jakarta.annotation.Resource;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

/**
 * 用户服务实现（只负责用户数据CRUD）
 */
@Service
@Slf4j
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {

    @Resource
    private AuthService authService;

    @Override
    public long userRegister(UserRegisterRequest userRegisterRequest) {
        // 1. 校验
        String userAccount = userRegisterRequest.getUserAccount();
        String userPassword = userRegisterRequest.getUserPassword();
        String checkPassword = userRegisterRequest.getCheckPassword();
        if (StrUtil.hasBlank(userAccount, userPassword, checkPassword)) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "参数为空");
        }
        if (userAccount.length() < 4) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "用户账号过短");
        }
        if (userPassword.length() < 8 || checkPassword.length() < 8) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "用户密码过短");
        }
        if (!userPassword.equals(checkPassword)) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "两次输入的密码不一致");
        }

        // 2. 检查账户是否重复
        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        queryWrapper.eq("userAccount", userAccount);
        long count = this.count(queryWrapper);
        if (count > 0) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "账号重复");
        }

        // 3. 加密
        String encryptPassword = DigestUtil.md5Hex(UserConstant.SALT + userPassword);

        // 4. 插入数据
        User user = new User();
        user.setUserAccount(userAccount);
        user.setUserPassword(encryptPassword);
        // 默认昵称
        user.setUserName("用户" + userAccount);
        user.setUserRole(UserRoleEnum.USER.getValue());
        boolean saveResult = this.save(user);
        if (!saveResult) {
            throw new BusinessException(ErrorCode.SYSTEM_ERROR, "注册失败，数据库错误");
        }
        return user.getId();
    }

    @Override
    public boolean updateMyUser(UserUpdateMyRequest userUpdateMyRequest, HttpServletRequest request) {
        // 1. 获取当前登录用户（通过AuthService）
        LoginUserVO loginUser = authService.getCurrentUser(request);
        User user = new User();
        user.setId(loginUser.getId());
        user.setUserName(userUpdateMyRequest.getUserName());
        user.setUserAvatar(userUpdateMyRequest.getUserAvatar());
        user.setUserProfile(userUpdateMyRequest.getUserProfile());
        // 2. 更新数据库
        return this.updateById(user);
    }

    /**
     * 获取脱敏后的用户信息
     *
     * @param user
     * @return
     */
    @Override
    public LoginUserVO getLoginUserVO(User user) {
        if (user == null) {
            return null;
        }
        LoginUserVO loginUserVO = new LoginUserVO();
        loginUserVO.setId(user.getId());
        loginUserVO.setUserAccount(user.getUserAccount());
        loginUserVO.setUserName(user.getUserName());
        loginUserVO.setUserAvatar(user.getUserAvatar());
        loginUserVO.setUserProfile(user.getUserProfile());
        loginUserVO.setUserRole(user.getUserRole());
        loginUserVO.setCreateTime(user.getCreateTime());
        loginUserVO.setUpdateTime(user.getUpdateTime());
        return loginUserVO;
    }
}
```

### 步骤2.5：重构 UserController

**修改文件**：`src/main/java/com/gdblogs/controller/UserController.java`

找到以下方法，修改为调用 `AuthService`：

```java
// 注入 AuthService
@Resource
private AuthService authService;

/**
 * 用户登录
 */
@PostMapping("/login")
public BaseResponse<LoginUserVO> userLogin(@RequestBody UserLoginRequest userLoginRequest, HttpServletRequest request) {
    LoginUserVO loginUserVO = authService.login(userLoginRequest, request);
    return ResultUtils.success(loginUserVO);
}

/**
 * 用户登出
 */
@PostMapping("/logout")
public BaseResponse<Boolean> userLogout(HttpServletRequest request) {
    boolean result = authService.logout(request);
    return ResultUtils.success(result);
}

/**
 * 获取当前登录用户
 */
@GetMapping("/get/login")
public BaseResponse<LoginUserVO> getLoginUser(HttpServletRequest request) {
    LoginUserVO loginUserVO = authService.getCurrentUser(request);
    return ResultUtils.success(loginUserVO);
}
```

### 步骤2.6：重构 AuthInterceptor

**修改文件**：`src/main/java/com/gdblogs/aop/AuthInterceptor.java`

```java
package com.gdblogs.aop;

import cn.hutool.core.util.StrUtil;
import com.gdblogs.annotation.AuthCheck;
import com.gdblogs.exception.ErrorCode;
import com.gdblogs.exception.BusinessException;
import com.gdblogs.model.enums.UserRoleEnum;
import com.gdblogs.service.AuthService;
import jakarta.annotation.Resource;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.RequestAttributes;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;
import jakarta.servlet.http.HttpServletRequest;

/**
 * 权限校验 AOP
 */
@Aspect
@Component
public class AuthInterceptor {

    @Resource
    private AuthService authService;

    /**
     * 执行拦截
     *
     * @param joinPoint 切入点
     * @param authCheck 注解
     * @return 结果
     */
    @Around("@annotation(authCheck)")
    public Object doInterceptor(ProceedingJoinPoint joinPoint, AuthCheck authCheck) throws Throwable {
        String mustRole = authCheck.mustRole();
        RequestAttributes requestAttributes = RequestContextHolder.currentRequestAttributes();
        HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();

        // 必须有该权限才通过
        if (StrUtil.isNotBlank(mustRole)) {
            // 1. 如果用户未登录，直接报错
            if (!authService.isAuthenticated(request)) {
                throw new BusinessException(ErrorCode.NOT_LOGIN_ERROR);
            }

            // 2. 如果要求的权限是 "admin" (管理员)
            if (UserRoleEnum.ADMIN.getValue().equals(mustRole)) {
                if (!authService.isAdmin(request)) {
                    throw new BusinessException(ErrorCode.NO_AUTH_ERROR);
                }
            }
            // 可以继续扩展其他角色判断...
        }

        // 如果 mustRole 为空，或者校验通过，继续执行原方法
        return joinPoint.proceed();
    }
}
```

### 步骤2.7：更新配置文件

**修改文件**：`src/main/resources/application-dev.yml`

```yaml
# 认证类型：session（Session认证）/ jwt（JWT认证）
auth:
  type: session
```

### 步骤2.8：未来扩展 - JWT 实现（可选）

**文件路径**：`src/main/java/com/gdblogs/service/impl/JwtAuthServiceImpl.java`

```java
package com.gdblogs.service.impl;

import com.gdblogs.model.dto.user.UserLoginRequest;
import com.gdblogs.model.vo.LoginUserVO;
import com.gdblogs.service.AuthService;
import jakarta.servlet.http.HttpServletRequest;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;

/**
 * JWT 认证服务实现（未来扩展）
 */
@Service
@Slf4j
@ConditionalOnProperty(name = "auth.type", havingValue = "jwt")
public class JwtAuthServiceImpl implements AuthService {

    // TODO: 注入 JWT 工具类

    @Override
    public LoginUserVO login(UserLoginRequest userLoginRequest, HttpServletRequest request) {
        // TODO: 实现 JWT 登录逻辑
        // 1. 验证用户名密码
        // 2. 生成 JWT Token
        // 3. 返回 Token
        throw new UnsupportedOperationException("JWT 认证尚未实现");
    }

    @Override
    public boolean logout(HttpServletRequest request) {
        // TODO: 实现 JWT 登出逻辑（可选，JWT 通常无状态）
        throw new UnsupportedOperationException("JWT 认证尚未实现");
    }

    @Override
    public LoginUserVO getCurrentUser(HttpServletRequest request) {
        // TODO: 从 Header 中获取 Token，解析用户信息
        throw new UnsupportedOperationException("JWT 认证尚未实现");
    }

    @Override
    public boolean isAuthenticated(HttpServletRequest request) {
        // TODO: 验证 Token 是否有效
        throw new UnsupportedOperationException("JWT 认证尚未实现");
    }

    @Override
    public boolean isAdmin(HttpServletRequest request) {
        // TODO: 从 Token 中获取角色信息
        throw new UnsupportedOperationException("JWT 认证尚未实现");
    }
}
```

---

## 阶段三：工作流服务预留

### 当前问题
- 目前没有审批流程
- 未来可能需要文章审核、多级审批等

### 目标
- 预留工作流接口
- 数据库字段预留
- 初期简单实现，未来可迁移到 Flowable

### 步骤3.1：创建工作流服务接口

**文件路径**：`src/main/java/com/gdblogs/service/WorkflowService.java`

```java
package com.gdblogs.service;

import java.util.List;
import java.util.Map;

/**
 * 工作流服务接口（预留，未来可对接 Flowable 等）
 */
public interface WorkflowService {
    
    /**
     * 启动流程实例
     * @param processKey 流程定义Key（如：article_approval）
     * @param businessKey 业务主键（如文章ID）
     * @param variables 流程变量
     * @return 流程实例ID
     */
    String startProcess(String processKey, String businessKey, Map<String, Object> variables);
    
    /**
     * 完成任务
     * @param taskId 任务ID
     * @param userId 用户ID
     * @param variables 流程变量
     */
    void completeTask(String taskId, String userId, Map<String, Object> variables);
    
    /**
     * 查询待办任务
     * @param userId 用户ID
     * @return 待办任务列表
     */
    List<Object> getTodoTasks(String userId);
    
    /**
     * 查询流程历史
     * @param processInstanceId 流程实例ID
     * @return 历史记录列表
     */
    List<Object> getProcessHistory(String processInstanceId);
    
    /**
     * 撤回流程
     * @param processInstanceId 流程实例ID
     * @param reason 撤回原因
     */
    void cancelProcess(String processInstanceId, String reason);
}
```

### 步骤3.2：创建简单实现（占位）

**文件路径**：`src/main/java/com/gdblogs/service/impl/SimpleWorkflowServiceImpl.java`

```java
package com.gdblogs.service.impl;

import com.gdblogs.service.WorkflowService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.List;
import java.util.Map;

/**
 * 简单工作流服务实现（占位，未来可替换为 Flowable）
 */
@Service
@Slf4j
@ConditionalOnProperty(name = "workflow.engine", havingValue = "simple", matchIfMissing = true)
public class SimpleWorkflowServiceImpl implements WorkflowService {

    @Override
    public String startProcess(String processKey, String businessKey, Map<String, Object> variables) {
        // 简单实现：直接返回业务主键作为流程实例ID
        log.info("启动流程: processKey={}, businessKey={}", processKey, businessKey);
        return "simple_" + businessKey;
    }

    @Override
    public void completeTask(String taskId, String userId, Map<String, Object> variables) {
        log.info("完成任务: taskId={}, userId={}", taskId, userId);
        // 简单实现：不做任何操作
    }

    @Override
    public List<Object> getTodoTasks(String userId) {
        log.info("查询待办任务: userId={}", userId);
        return Collections.emptyList();
    }

    @Override
    public List<Object> getProcessHistory(String processInstanceId) {
        log.info("查询流程历史: processInstanceId={}", processInstanceId);
        return Collections.emptyList();
    }

    @Override
    public void cancelProcess(String processInstanceId, String reason) {
        log.info("撤回流程: processInstanceId={}, reason={}", processInstanceId, reason);
    }
}
```

### 步骤3.3：在 Post 实体中预留字段

**修改文件**：`src/main/java/com/gdblogs/model/entity/Post.java`

在 `Post` 类中添加以下字段：

```java
/**
 * 流程实例ID（未来对接工作流引擎）
 */
private String processInstanceId;

/**
 * 流程定义Key（如：article_approval）
 */
private String processDefinitionKey;

/**
 * 当前审批状态（pending/reviewing/approved/rejected）
 */
private String approvalStatus;

/**
 * 审批人ID（当前节点）
 */
private Long currentApproverId;
```

### 步骤3.4：数据库迁移脚本

**文件路径**：`src/main/resources/sql/add_workflow_fields.sql`

```sql
-- 为 post 表添加工作流字段
ALTER TABLE post ADD COLUMN process_instance_id VARCHAR(64) NULL COMMENT '流程实例ID';
ALTER TABLE post ADD COLUMN process_definition_key VARCHAR(64) NULL COMMENT '流程定义Key';
ALTER TABLE post ADD COLUMN approval_status VARCHAR(32) NULL COMMENT '审批状态';
ALTER TABLE post ADD COLUMN current_approver_id BIGINT NULL COMMENT '当前审批人ID';

-- 添加索引
CREATE INDEX idx_process_instance_id ON post(process_instance_id);
CREATE INDEX idx_approval_status ON post(approval_status);
```

### 步骤3.5：更新配置文件

**修改文件**：`src/main/resources/application-dev.yml`

```yaml
# 工作流引擎：simple（简单实现）/ flowable（Flowable引擎）
workflow:
  engine: simple
```

### 步骤3.6：未来扩展 - Flowable 实现（可选）

**文件路径**：`src/main/java/com/gdblogs/service/impl/FlowableWorkflowServiceImpl.java`

```java
package com.gdblogs.service.impl;

import com.gdblogs.service.WorkflowService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;

/**
 * Flowable 工作流服务实现（未来扩展）
 */
@Service
@Slf4j
@ConditionalOnProperty(name = "workflow.engine", havingValue = "flowable")
public class FlowableWorkflowServiceImpl implements WorkflowService {

    // TODO: 注入 Flowable 相关服务
    // @Resource
    // private RuntimeService runtimeService;
    // @Resource
    // private TaskService taskService;

    @Override
    public String startProcess(String processKey, String businessKey, Map<String, Object> variables) {
        // TODO: 使用 Flowable API 启动流程
        // ProcessInstance instance = runtimeService.startProcessInstanceByKey(
        //     processKey, businessKey, variables
        // );
        // return instance.getId();
        throw new UnsupportedOperationException("Flowable 引擎尚未实现");
    }

    @Override
    public void completeTask(String taskId, String userId, Map<String, Object> variables) {
        // TODO: 使用 Flowable API 完成任务
        throw new UnsupportedOperationException("Flowable 引擎尚未实现");
    }

    @Override
    public List<Object> getTodoTasks(String userId) {
        // TODO: 使用 Flowable API 查询待办
        throw new UnsupportedOperationException("Flowable 引擎尚未实现");
    }

    @Override
    public List<Object> getProcessHistory(String processInstanceId) {
        // TODO: 使用 Flowable API 查询历史
        throw new UnsupportedOperationException("Flowable 引擎尚未实现");
    }

    @Override
    public void cancelProcess(String processInstanceId, String reason) {
        // TODO: 使用 Flowable API 撤回流程
        throw new UnsupportedOperationException("Flowable 引擎尚未实现");
    }
}
```

**添加 Flowable 依赖**（pom.xml）：

```xml
<!-- Flowable（未来扩展） -->
<!--
<dependency>
    <groupId>org.flowable</groupId>
    <artifactId>flowable-spring-boot-starter</artifactId>
    <version>6.8.0</version>
</dependency>
-->
```

---

## 阶段四：通知服务扩展

### 当前问题
- 只支持站内通知
- 未来可能需要邮件、短信、微信推送等

### 目标
- 抽象通知发送接口
- 支持多渠道通知
- 支持异步发送

### 步骤4.1：创建通知发送服务接口

**文件路径**：`src/main/java/com/gdblogs/service/NotificationSenderService.java`

```java
package com.gdblogs.service;

import com.gdblogs.model.enums.NotificationTypeEnum;

import java.util.List;

/**
 * 通知发送服务接口
 * 支持站内通知、邮件、短信、微信推送等
 */
public interface NotificationSenderService {
    
    /**
     * 发送通知
     * @param userId 用户ID
     * @param type 通知类型
     * @param title 标题
     * @param content 内容
     * @param channels 发送渠道（inapp/email/sms/wechat）
     */
    void sendNotification(Long userId, NotificationTypeEnum type, 
                         String title, String content, List<String> channels);
    
    /**
     * 批量发送通知
     * @param userIds 用户ID列表
     * @param type 通知类型
     * @param title 标题
     * @param content 内容
     * @param channels 发送渠道
     */
    void sendBatchNotification(List<Long> userIds, NotificationTypeEnum type,
                              String title, String content, List<String> channels);
    
    /**
     * 异步发送通知
     * @param userId 用户ID
     * @param type 通知类型
     * @param title 标题
     * @param content 内容
     * @param channels 发送渠道
     */
    void sendNotificationAsync(Long userId, NotificationTypeEnum type,
                              String title, String content, List<String> channels);
}
```

### 步骤4.2：创建站内通知实现

**文件路径**：`src/main/java/com/gdblogs/service/impl/InAppNotificationSenderImpl.java`

```java
package com.gdblogs.service.impl;

import com.gdblogs.model.entity.Notification;
import com.gdblogs.model.enums.NotificationTypeEnum;
import com.gdblogs.service.NotificationSenderService;
import com.gdblogs.service.NotificationService;
import jakarta.annotation.Resource;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 站内通知发送实现
 */
@Service
@Slf4j
public class InAppNotificationSenderImpl implements NotificationSenderService {

    @Resource
    private NotificationService notificationService;

    @Override
    public void sendNotification(Long userId, NotificationTypeEnum type, 
                                String title, String content, List<String> channels) {
        if (channels != null && channels.contains("inapp")) {
            Notification notification = new Notification();
            notification.setUserId(userId);
            notification.setType(type.getValue());
            notification.setTitle(title);
            notification.setContent(content);
            notification.setIsRead(0);
            notificationService.save(notification);
            log.info("发送站内通知: userId={}, title={}", userId, title);
        }
    }

    @Override
    public void sendBatchNotification(List<Long> userIds, NotificationTypeEnum type,
                                     String title, String content, List<String> channels) {
        if (channels != null && channels.contains("inapp")) {
            for (Long userId : userIds) {
                sendNotification(userId, type, title, content, channels);
            }
        }
    }

    @Async
    @Override
    public void sendNotificationAsync(Long userId, NotificationTypeEnum type,
                                     String title, String content, List<String> channels) {
        sendNotification(userId, type, title, content, channels);
    }
}
```

### 步骤4.3：未来扩展 - 邮件通知（可选）

**文件路径**：`src/main/java/com/gdblogs/service/impl/EmailNotificationSenderImpl.java`

```java
package com.gdblogs.service.impl;

import com.gdblogs.model.enums.NotificationTypeEnum;
import com.gdblogs.service.NotificationSenderService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;

import java.util.List;

/**
 * 邮件通知发送实现（未来扩展）
 */
@Service
@Slf4j
public class EmailNotificationSenderImpl implements NotificationSenderService {

    // TODO: 注入邮件发送服务
    // @Resource
    // private JavaMailSender mailSender;

    @Override
    public void sendNotification(Long userId, NotificationTypeEnum type,
                                String title, String content, List<String> channels) {
        if (channels != null && channels.contains("email")) {
            // TODO: 实现邮件发送逻辑
            log.info("发送邮件通知: userId={}, title={}", userId, title);
        }
    }

    @Override
    public void sendBatchNotification(List<Long> userIds, NotificationTypeEnum type,
                                     String title, String content, List<String> channels) {
        if (channels != null && channels.contains("email")) {
            for (Long userId : userIds) {
                sendNotification(userId, type, title, content, channels);
            }
        }
    }

    @Async
    @Override
    public void sendNotificationAsync(Long userId, NotificationTypeEnum type,
                                     String title, String content, List<String> channels) {
        sendNotification(userId, type, title, content, channels);
    }
}
```

### 步骤4.4：启用异步支持

**修改文件**：`src/main/java/com/gdblogs/GdblogsApplication.java`

```java
package com.gdblogs;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableAsync;

@SpringBootApplication
@EnableAsync  // 启用异步支持
public class GdblogsApplication {
    public static void main(String[] args) {
        SpringApplication.run(GdblogsApplication.class, args);
    }
}
```

---

## 阶段五：缓存服务抽象

### 当前问题
- 目前没有缓存
- 未来可能需要缓存热门数据

### 目标
- 抽象缓存服务接口
- 支持本地缓存、Redis 等

### 步骤5.1：创建缓存服务接口

**文件路径**：`src/main/java/com/gdblogs/service/CacheService.java`

```java
package com.gdblogs.service;

import java.util.concurrent.TimeUnit;

/**
 * 缓存服务接口
 * 支持本地缓存、Redis 等
 */
public interface CacheService {
    
    /**
     * 获取缓存
     * @param key 键
     * @param type 类型
     * @return 值
     */
    <T> T get(String key, Class<T> type);
    
    /**
     * 设置缓存
     * @param key 键
     * @param value 值
     * @param timeout 过期时间
     * @param unit 时间单位
     */
    void set(String key, Object value, long timeout, TimeUnit unit);
    
    /**
     * 删除缓存
     * @param key 键
     */
    void delete(String key);
    
    /**
     * 判断是否存在
     * @param key 键
     * @return 是否存在
     */
    boolean exists(String key);
    
    /**
     * 设置永久缓存
     * @param key 键
     * @param value 值
     */
    void setForever(String key, Object value);
}
```

### 步骤5.2：创建本地缓存实现

**文件路径**：`src/main/java/com/gdblogs/service/impl/LocalCacheServiceImpl.java`

```java
package com.gdblogs.service.impl;

import com.gdblogs.service.CacheService;
import com.github.benmanes.caffeine.cache.Cache;
import com.github.benmanes.caffeine.cache.Caffeine;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

/**
 * 本地缓存服务实现（基于 Caffeine）
 */
@Service
@Slf4j
@ConditionalOnProperty(name = "cache.type", havingValue = "local", matchIfMissing = true)
public class LocalCacheServiceImpl implements CacheService {

    private final Cache<String, Object> cache;

    public LocalCacheServiceImpl() {
        this.cache = Caffeine.newBuilder()
                .maximumSize(10000)
                .expireAfterWrite(60, TimeUnit.MINUTES)
                .build();
    }

    @Override
    @SuppressWarnings("unchecked")
    public <T> T get(String key, Class<T> type) {
        Object value = cache.getIfPresent(key);
        if (value != null && type.isInstance(value)) {
            return (T) value;
        }
        return null;
    }

    @Override
    public void set(String key, Object value, long timeout, TimeUnit unit) {
        cache.put(key, value);
        // Caffeine 不支持单独设置过期时间，这里只是演示
        log.debug("缓存设置: key={}, timeout={}{}",  key, timeout, unit);
    }

    @Override
    public void delete(String key) {
        cache.invalidate(key);
    }

    @Override
    public boolean exists(String key) {
        return cache.getIfPresent(key) != null;
    }

    @Override
    public void setForever(String key, Object value) {
        cache.put(key, value);
    }
}
```

### 步骤5.3：添加 Caffeine 依赖

**修改文件**：`pom.xml`

```xml
<!-- Caffeine 本地缓存 -->
<dependency>
    <groupId>com.github.ben-manes.caffeine</groupId>
    <artifactId>caffeine</artifactId>
    <version>3.1.8</version>
</dependency>
```

### 步骤5.4：未来扩展 - Redis 缓存（可选）

**文件路径**：`src/main/java/com/gdblogs/service/impl/RedisCacheServiceImpl.java`

```java
package com.gdblogs.service.impl;

import com.gdblogs.service.CacheService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.stereotype.Service;

import java.util.concurrent.TimeUnit;

/**
 * Redis 缓存服务实现（未来扩展）
 */
@Service
@Slf4j
@ConditionalOnProperty(name = "cache.type", havingValue = "redis")
public class RedisCacheServiceImpl implements CacheService {

    // TODO: 注入 RedisTemplate
    // @Resource
    // private RedisTemplate<String, Object> redisTemplate;

    @Override
    public <T> T get(String key, Class<T> type) {
        // TODO: 实现 Redis 获取逻辑
        throw new UnsupportedOperationException("Redis 缓存尚未实现");
    }

    @Override
    public void set(String key, Object value, long timeout, TimeUnit unit) {
        // TODO: 实现 Redis 设置逻辑
        throw new UnsupportedOperationException("Redis 缓存尚未实现");
    }

    @Override
    public void delete(String key) {
        // TODO: 实现 Redis 删除逻辑
        throw new UnsupportedOperationException("Redis 缓存尚未实现");
    }

    @Override
    public boolean exists(String key) {
        // TODO: 实现 Redis 判断逻辑
        throw new UnsupportedOperationException("Redis 缓存尚未实现");
    }

    @Override
    public void setForever(String key, Object value) {
        // TODO: 实现 Redis 永久存储逻辑
        throw new UnsupportedOperationException("Redis 缓存尚未实现");
    }
}
```

### 步骤5.5：更新配置文件

**修改文件**：`src/main/resources/application-dev.yml`

```yaml
# 缓存类型：local（本地缓存）/ redis（Redis缓存）
cache:
  type: local
```

---

## 执行检查清单

### 阶段一：文件存储服务（优先级：最高）
- [ ] 创建 `FileStorageService` 接口
- [ ] 创建 `LocalFileStorageServiceImpl` 实现类
- [ ] 重构 `FileController`（移除文件操作逻辑）
- [ ] 更新 `application-dev.yml` 配置文件
- [ ] 测试文件上传功能
- [ ] （可选）准备 OSS 实现类

### 阶段二：认证服务（优先级：高）
- [ ] 创建 `AuthService` 接口
- [ ] 创建 `SessionAuthServiceImpl` 实现类
- [ ] 重构 `UserService` 接口（移除认证相关方法）
- [ ] 重构 `UserServiceImpl`（调用 AuthService）
- [ ] 重构 `UserController`（调用 AuthService）
- [ ] 重构 `AuthInterceptor`（调用 AuthService）
- [ ] 更新 `application-dev.yml` 配置文件
- [ ] 测试登录、登出、权限功能
- [ ] （可选）准备 JWT 实现类

### 阶段三：工作流服务（优先级：中）
- [ ] 创建 `WorkflowService` 接口
- [ ] 创建 `SimpleWorkflowServiceImpl` 实现类
- [ ] 修改 `Post` 实体（添加流程字段）
- [ ] 执行数据库迁移脚本
- [ ] 更新 `application-dev.yml` 配置文件
- [ ] （可选）准备 Flowable 实现类

### 阶段四：通知服务（优先级：中）
- [ ] 创建 `NotificationSenderService` 接口
- [ ] 创建 `InAppNotificationSenderImpl` 实现类
- [ ] 修改 `GdblogsApplication`（启用异步支持）
- [ ] （可选）准备邮件、短信实现类

### 阶段五：缓存服务（优先级：中-低）
- [ ] 创建 `CacheService` 接口
- [ ] 添加 Caffeine 依赖
- [ ] 创建 `LocalCacheServiceImpl` 实现类
- [ ] 更新 `application-dev.yml` 配置文件
- [ ] （可选）准备 Redis 实现类

---

## 注意事项

### 重构原则
1. **渐进式重构**：按阶段执行，每完成一个阶段测试一次
2. **Git 提交**：每个阶段完成后提交代码，便于回滚
3. **向后兼容**：先不改动现有功能，确保系统稳定
4. **配置化切换**：使用 `@ConditionalOnProperty` 实现配置化切换
5. **接口简洁**：避免过度设计，只抽象必要的方法

### 测试要点
1. **单元测试**：为每个接口编写单元测试
2. **集成测试**：测试接口切换功能
3. **性能测试**：确保抽象层不影响性能
4. **兼容性测试**：确保现有功能正常

### 常见问题

#### Q1：如何切换实现？
A：修改配置文件中的 `type` 属性，重启应用即可。

```yaml
storage:
  type: oss  # 从 local 切换到 oss
```

#### Q2：多个实现可以同时使用吗？
A：可以，使用 `@Qualifier` 或 `@Primary` 注解指定优先级。

```java
@Resource
@Qualifier("localFileStorageServiceImpl")
private FileStorageService localStorage;

@Resource
@Qualifier("ossFileStorageServiceImpl")
private FileStorageService ossStorage;
```

#### Q3：如何添加新的实现？
A：实现对应的接口，添加 `@ConditionalOnProperty` 注解即可。

```java
@Service
@ConditionalOnProperty(name = "storage.type", havingValue = "minio")
public class MinioFileStorageServiceImpl implements FileStorageService {
    // 实现逻辑
}
```

#### Q4：性能会受影响吗？
A：抽象层几乎不影响性能，接口调用在 JVM 中会被优化。

#### Q5：需要添加依赖吗？
A：
- 本地缓存需要 Caffeine
- OSS 需要对应的 SDK
- Flowable 需要对应的依赖

---

## 配置文件汇总

### 完整的 application-dev.yml

```yaml
server:
  port: 8124

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/gd_blogs?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&allowMultiQueries=true&useSSL=false&allowPublicKeyRetrieval=true
    username: root
    password: 1234
    driver-class-name: com.mysql.cj.jdbc.Driver

# 文件存储配置
file:
  upload-dir: C:/Users/Administrator/Desktop/gd-blogs/blogs-backend/gdblogs/src/main/resources/images/
  base-url: # 可选，用于CDN场景

# 存储类型：local（本地）/ oss（阿里云OSS）/ minio（MinIO）
storage:
  type: local

# 认证类型：session（Session认证）/ jwt（JWT认证）
auth:
  type: session

# 工作流引擎：simple（简单实现）/ flowable（Flowable引擎）
workflow:
  engine: simple

# 缓存类型：local（本地缓存）/ redis（Redis缓存）
cache:
  type: local

knife4j:
  enable: true
```

---

## 总结

### 重构收益
1. **可扩展性**：轻松切换存储、认证、缓存等实现
2. **可测试性**：接口可 mock，单元测试更简单
3. **可维护性**：职责清晰，代码结构更合理
4. **灵活性**：配置化切换，无需修改代码

### 未来扩展路径

```
阶段1：本地存储 + Session 认证
  ↓
阶段2：OSS 存储 + Session 认证
  ↓
阶段3：OSS 存储 + JWT 认证
  ↓
阶段4：OSS 存储 + JWT 认证 + Redis 缓存
  ↓
阶段5：OSS 存储 + JWT 认证 + Redis 缓存 + Flowable 工作流
```

### 开始重构
建议从**阶段一：文件存储服务**开始，这是最容易验证效果的部分。

祝重构顺利！🚀
